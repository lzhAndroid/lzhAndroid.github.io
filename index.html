<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Mr.Monkey&#39;s Pages</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Mr.Monkey's Pages">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Mr.Monkey's Pages">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Mr.Monkey's Pages">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Mr.Monkey&#39;s Pages" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://raw.githubusercontent.com/lzhAndroid/lzhAndroid.github.io/master/img/avatar.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Mr.Monkey</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Mr.Monkey</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img src="https://raw.githubusercontent.com/lzhAndroid/lzhAndroid.github.io/master/img/avatar.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Mr.Monkey</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-trident_framework_guide" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/05/trident_framework_guide/" class="article-date">
  	<time datetime="2016-06-05T09:55:40.000Z" itemprop="datePublished">2016-06-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="trident-framework的使用以及遇到的问题">Trident Framework的使用以及遇到的问题</h2>
<h3 id="先上一张整体的类图">先上一张整体的类图</h3>
<p><img src="https://raw.githubusercontent.com/lzhAndroid/image/master/trident_framework_class.jpg"> <strong>Base**</strong>这一类的Fragment主要是针对当前项目的一些配置，比如全局的标题设置，数据内容为空的一些判断。<strong>Framework**</strong>这一类的Framework主要是出于跨项目的重用进行构建的，主要做一些下拉刷新，下拉加载更多，提供一些非固定实现的接口，都是一些便于新项目的扩展的一些实现。</p>
<h3 id="给activity添加titlebar">给Activity添加titleBar</h3>
<p>通过重写BaseActivity中的ITitleDataBinder接口，来实现标题栏的各个部分</p>
<h4 id="添加标题">添加标题</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 更新中间标题</span><br><span class="line"> * <span class="doctag">@param</span> view 标题控件</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateMiddleView</span><span class="params">(TextView view)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="给textview添加图标和标题">给TextView添加图标和标题</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Drawable left = mAct.getResources().getDrawable(R.drawable.title_ico);</span><br><span class="line">    left.setBounds(<span class="number">0</span>, <span class="number">0</span>, left.getMinimumWidth(),</span><br><span class="line">    left.getMinimumHeight());</span><br><span class="line">mLeftTxtView.setText(<span class="string">"Miliyo"</span>);</span><br><span class="line">mLeftTxtView.setCompoundDrawables(left, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<h4 id="获取动态数据更新标题">获取动态数据，更新标题</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 更新标题数据</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyTitleData</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>动态数据是指服务端返回的数据，或者Activity onCreate调用之前没有办法确定的数据，通过<strong>notifyTitleData</strong>来更新数据，可以避免回调时，标题栏已经被销毁的情况。<strong>切忌不要在Fragment和Activity对象中，持有titleBar控件的引用</strong>。</p>
</blockquote>
<h4 id="标题栏右侧添加小红点或数字角标">标题栏右侧添加小红点或数字角标</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateRightViewTip</span><span class="params">(TextView view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = util.getCommentNew();</span><br><span class="line">    <span class="keyword">if</span>(num &gt;<span class="number">0</span>)&#123;</span><br><span class="line">        view.setVisibility(View.VISIBLE);</span><br><span class="line">        view.setBackgroundResource(R.drawable.shape_msg_num);</span><br><span class="line">        view.setCompoundDrawables(<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">        view.setText(String.valueOf(num));</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        view.setVisibility(View.GONE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多action的标题栏">多Action的标题栏</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] mActionIds = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;R.id.title_action1, R.id.title_action2, R.id.title_action3, R.id.title_action4&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] mActionStrings = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;R.string.online, R.string.dating, R.string.trip, R.string.like&#125;;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update4ActionTitle</span><span class="params">(ViewGroup viewParent)</span> </span>&#123;</span><br><span class="line">    viewParent.setVisibility(View.VISIBLE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mActionIds.length; i++) &#123;</span><br><span class="line">        mActionTextViews[i] = (TextView) viewParent.findViewById(mActionIds[i]);</span><br><span class="line">        mActionTextViews[i].setText(mActionStrings[i]);</span><br><span class="line">        mActionTextViews[i].setOnClickListener(mActionClickListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，leftView默认设置的是返回图标，middleView默认设置是可见的，其它各个部件都是设置为不可见，需要使用时，请先设置<strong>setVisibility(View.VISIBLE)</strong>;</p>
</blockquote>
<h4 id="给fragment设置标题">给Fragment设置标题</h4>
<p>原则上建议，针对Activity来进行标题栏设置，但有时候需求中，我们也会遇到多个Fragment共有一个Activity的情况，例如主页这类的需求，我们需要在对Fragment进行切换操作的时候，更新Activity标题栏的数据 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrimaryItem</span><span class="params">(ViewGroup container, <span class="keyword">int</span> position, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setPrimaryItem(container, position, object);</span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ITitleDataBinder) &#123;</span><br><span class="line">        mTitleTool.binding((ITitleDataBinder) object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>setPrimaryItem是位于SimpleViewPagerStateAdapter中的方法，当Viewpager中的current Fragment发生变化时会主动调用</p>
</blockquote>
<h4 id="不使用标题栏">不使用标题栏</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasTitleBar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标题栏默认的更新时机">标题栏默认的更新时机</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    mTitleTool = DefaultTitleTool.createInstance();</span><br><span class="line">    <span class="keyword">if</span> (hasTitleBar()) &#123;</span><br><span class="line">        View rootView = mTitleTool.addTitleView(</span><br><span class="line">                getApplicationContext(),</span><br><span class="line">                getLayoutInflater().inflate(layoutResID,</span><br><span class="line">                        getDecotatorView(), <span class="keyword">false</span>), getDecotatorView());</span><br><span class="line">        mTitleTool.binding(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">super</span>.setContentView(rootView);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.setContentView(layoutResID);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>标题栏的更新实现是在Activity的setContentView方法中，如果标题栏使用有遇到和预期不符的情况，请检查setContentView的参数,int类型的参数调用和View类型的参数调用产生的结果不一样</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="一个简单的列表需求">一个简单的列表需求</h3>
<p>首先我们需要继承BaseRecycleFragment，该类暂时只提供了LinearLayoutManager的支持，后期可能会对九宫格和瀑布流进行支持。需要做一个简单列表，首先我们需要实现<strong>网络请求</strong>接口<strong>sendRequest()</strong>,该方法是在<strong>onActivityCreate()</strong>中进行调用的，所以重写onActivityCreate()方法时请记得加上super.onActivityCreate()。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    GsonRequest&lt;Person&gt; request = <span class="keyword">new</span> GsonRequest&lt;&gt;(SIMPLE_URL);</span><br><span class="line">    <span class="comment">// 设置自定义的gson解析工具，项目中需要对GsonString，</span></span><br><span class="line">    <span class="comment">// EmojiString这种特定类型的数据做处理的时候，需要设置</span></span><br><span class="line">    <span class="comment">// 项目中默认使用具有GsonString类型解析的构建器</span></span><br><span class="line">    <span class="comment">// 如果需要解析带emoji表情的数据时，需要使用到miliyo中的具体构建器</span></span><br><span class="line">    request.setGson(GsonUtil.getGsonSringBuilderGson());</span><br><span class="line">    request.setClazz(Person.class);<span class="comment">//设置返回值类型，默认类型为JSONObject</span></span><br><span class="line">    request.addPostParam(<span class="string">"uid"</span>, <span class="number">18</span>);<span class="comment">//添加post参数</span></span><br><span class="line">    request.addUrlParam(<span class="string">"token"</span>, <span class="string">"fjdlsjhdf8392"</span>);<span class="comment">//添加Url参数</span></span><br><span class="line">    request.setAutoHanderException(<span class="keyword">true</span>);<span class="comment">//设置是否需要全局进行异常处理</span></span><br><span class="line">    request.setLogAble(<span class="keyword">true</span>);<span class="comment">//是否需要打印请求地址，参数和请求返回结果</span></span><br><span class="line">    </span><br><span class="line">    request.setCallback(<span class="keyword">new</span> ICallback&lt;Person&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(Person entity)</span> </span>&#123;</span><br><span class="line">            CLog.d(TAG, String.format(<span class="string">"callback,name is %s,age is %s"</span>, entity.name, entity.age));</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onHasAnyException</span><span class="params">(VolleyError e)</span> </span>&#123;</span><br><span class="line">            CLog.d(TAG, <span class="string">"onHasAnyException"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//execute可接受Fragment，Context两种参数，区别在于，</span></span><br><span class="line">    <span class="comment">// 传入参数的生命周期影响callback的调用,如果传入的是application的context</span></span><br><span class="line">    <span class="comment">// 则不论activity或者fragment是否销毁，都会回调callback</span></span><br><span class="line">    request.execute(fragment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们假设服务端返回的实体对象Person中有一个List<friend>的数据对象，用来返回这个人的朋友列表，我们可以在<strong>callback</strong>方法中实现数据绑定到UI界面 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(entity.friends!=<span class="keyword">null</span>)&#123;</span><br><span class="line">    <span class="keyword">for</span>(Friend friend:entity.friends)&#123;</span><br><span class="line">        getContentData().add(<span class="keyword">new</span> FriendItem(friend));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">getAdapter().notifyDataSetChanged()</span><br></pre></td></tr></table></figure></friend></p>
<p>上面方法实现了把数据添加到Content列表中，并更新显示。RecycleFragment提供getHeaderData,getFooterData,getContentData 三个数据集合对象，他们的区别在于，数据显示在头部还是尾部，类似于ListView的HeaderView，FooterView。 在一些具体实现中，我们会有<strong>刷新时清空数据，数据为空时显示EmptyView，遇到网络异常显示ErrorView</strong>这类需求，这时候为了处理这种重复需求，我们可以实现RecycleCallback,这是一个ICallback的代理实现，它提供了我们上面所说的这些需求的基本实现。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> RecycleCallback(</span><br><span class="line">    <span class="keyword">new</span> ICallback&lt;Person&gt;() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callback</span><span class="params">(Person entity)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(entity.friends!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(Friend friend:entity.friends)&#123;</span><br><span class="line">                    getContentData().add(<span class="keyword">new</span> FriendItem(friend));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onHasAnyException</span><span class="params">(VolleyError e)</span> </span>&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p>
<p>可以发现，实际callback中的代码比之前的代码还少了notifyDatasetChanged过程，这是因为在代理内中，上层代码已经代为调用了，可以看到，我们实现了更多的额外功能，但是代码反而相对精简了。</p>
<p>下面我们看一下<strong>FriendItem</strong>的实现 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendItem</span> <span class="keyword">extends</span> <span class="title">MultiBaseItem</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mInfo;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FriendItem</span><span class="params">(Friend info)</span> </span>&#123;</span><br><span class="line">        mInfo=info;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ItemCreator ITEM_CREATOR = <span class="keyword">new</span> ItemCreator() &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> RecyclerView.<span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent)</span> </span>&#123;</span><br><span class="line">            View view = LayoutInflater.from(parent.getContext()).inflate(</span><br><span class="line">                    R.layout.item_friend, parent, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> FriendHolder(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ItemCreator <span class="title">getCreator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ITEM_CREATOR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FriendHoldler</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">        TextView convertView;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">FriendHoldler</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(view);</span><br><span class="line">            <span class="keyword">this</span>.convertView=(TextView)view;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder, FrameworkRecycleFragment fragment, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onBindViewHolder(holder, fragment, position);</span><br><span class="line">        FriendHoldler vh = (FriendHolder)holder;</span><br><span class="line">        vh.convertView.setText(mInfo.name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MultiBaseItem是ItemCreatorable的抽象实现，我们需要去重写实现 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder vh, FrameworkRecycleFragment fragment, <span class="keyword">int</span> position)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>需要调用Adapter等操作，可以通过参数fragment.getAdapter()来获取，上述方法主要用来处理数据和ViewHolder绑定的逻辑 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ItemCreator <span class="title">getCreator</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>通过getCreator返回一个ItemCreator，需要注意的是，这个ItemCreator实例是用来区分Item的类型的，所以一定要确保是单例的对象，建议写法是，返回一个<strong>static</strong>的对象，如下所示代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ItemCreator ITEM_CREATOR = <span class="keyword">new</span> ItemCreator() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RecyclerView.<span class="function">ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent)</span> </span>&#123;</span><br><span class="line">        View view = LayoutInflater.from(parent.getContext()).inflate(</span><br><span class="line">                R.layout.item_friend, parent, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FriendHolder(view);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>现在我们还需要实现的就只剩下item_friend的layout布局。</p>
<blockquote>
<p>如果我们需要实现一个<strong>多类型</strong>的列表，我们只需要向Adapter的ContentData，HeaderData,FooterData中add不同的ItemCreatorable。</p>
</blockquote>
<h4 id="序列化列表">序列化列表</h4>
<blockquote>
<p>下面的代码是ParcelRecycleFragment中的默认实现，如果有特殊需求，可以按照自己的需要重写该方法</p>
</blockquote>
<p>使用Bundle中的序列化数据恢复界面,返回true则不调用onCreateInit恢复数据 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (savedInstanceState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ArrayList&lt;T&gt; contentData = savedInstanceState.getParcelableArrayList(KEY_CONTENT_DATA);</span><br><span class="line">        isLoadingMore = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(contentData != <span class="keyword">null</span> &amp;&amp; contentData.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            getContentData().clear();</span><br><span class="line">            <span class="keyword">for</span> (T info:contentData)&#123;</span><br><span class="line">                <span class="keyword">if</span>(info==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">                &#125;</span><br><span class="line">                getContentData().add(info);</span><br><span class="line">            &#125;</span><br><span class="line">            getAdapter().notifyDataSetChanged();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>保存数据到Bundle <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">    outState.putParcelableArrayList(KEY_CONTENT_DATA, (ArrayList&lt;? extends Parcelable&gt;) getContentData());</span><br><span class="line">    <span class="keyword">if</span>(mEmptyItem!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        outState.putParcelable(KEY_EMPTY_ITEM, mEmptyItem);</span><br><span class="line">        outState.putInt(KEY_EMPTY_SHOW,isShowEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="faq">FAQ</h3>
<h4 id="关于自动刷新和手动刷新">关于自动刷新和手动刷新</h4>
<p>**DataFragment中的autoRefresh方法，sendRequest的区别在于，是否需要在刷新的时候，调用控件的下拉刷新动画。autoRefresh方法会触发下拉的动画同时，调用sendRequest()，autoRefresh()方法默认是在onCreateInit()调用的，onCreateInit()的调用是在onActivityCreate()当中。不建议重写refreshUI方法，如果有需要重写，可以组内做适当讨论。</p>
<h4 id="列表对应的fragment基类具体是哪一个非列表一般继承哪个fragment.">列表对应的fragment基类具体是哪一个，非列表一般继承哪个fragment.</h4>
<p>列表类型的Fragment，如果不需要进行序列化保存操作的话，继承BaseRecycleFragment,如果需要进行序列化操作的话，继承ParcelRecycleFragment。非列表需要有下拉刷新操作或者网络请求操作的类继承自BaseDataFragment，只是纯界面显示，不需要根据网络数据初始化界面的，使用BaseFragment。</p>
<h4 id="fragment中主要方法的调用顺序我们做初始化操作和注册广播最好在哪个方法里面调用比较好">fragment中主要方法的调用顺序，我们做初始化操作和注册广播最好在哪个方法里面调用比较好。</h4>
<p>注册广播等初始化等需要Activity context环境的操作建议在onActivityCreate中实现，onCreateInit可以确保在Activity初始化和序列化失败的时候调用。项目中建议使用initView来替代onCreateView方法。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-glide_guide" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/03/glide_guide/" class="article-date">
  	<time datetime="2016-06-03T02:55:37.000Z" itemprop="datePublished">2016-06-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="glide使用及需要注意的事项">Glide使用及需要注意的事项</h2>
<p>Glide的更多调用，可以参考<a href="http://mrfu.me/2016/02/27/Glide_Getting_Started/" target="_blank" rel="external">Glide的官方文档译文</a>,<a href="https://github.com/bumptech/glide/wiki" target="_blank" rel="external">Glide Wiki</a> ###使用Glide加载图片 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ImageView targetImageView = (ImageView) findViewById(R.id.imageView);</span><br><span class="line">String internetUrl = <span class="string">"http://i.imgur.com/DvpvklR.png"</span>;</span><br><span class="line"></span><br><span class="line">Glide</span><br><span class="line">    .with(context)</span><br><span class="line">    .load(internetUrl)</span><br><span class="line">    .into(targetImageView);</span><br></pre></td></tr></table></figure></p>
<p>在这里需要<strong>注意</strong>的是，targetImageView如果大小是<strong>动态变化</strong>的，比如在项目需求中，我们需要GridView中的Item图片宽度等于高度，在listview或者gridView中<strong>频繁加载调用</strong>的话，有可能导致图片出现错乱或者加载不成功，<strong>解决方法</strong>是，使用<strong>override()</strong>方法固定图片源的宽高，避免短时间内多次重复加载。</p>
<p>这里的into方法还有很多的重载，具体的使用可以参考Glide的官方译文。</p>
<h3 id="使用glide的扩展库对图片进行处理">使用Glide的扩展库，对图片进行处理</h3>
<p><a href="https://github.com/wasabeef/glide-transformations" target="_blank" rel="external">glide-transformations</a>是一个基于Glide的transformation库，拥有圆角，裁剪，着色，模糊，滤镜等多种转换效果，以下主要介绍项目中常用的几种处理，需要有其它特效的可以自己去看github的使用说明。 ####裁剪一个圆形图片 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>).load(R.drawable.demo)</span><br><span class="line">  .bitmapTransform(<span class="keyword">new</span> CropCircleTransformation(context))</span><br><span class="line">  .into((ImageView) findViewById(R.id.image));</span><br></pre></td></tr></table></figure></p>
<p>如果需要裁剪一个<strong>圆角图片</strong>，可以使用<strong>RoundedCornersTransformation（）</strong>， ####高斯模糊 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Glide.with(<span class="keyword">this</span>).load(R.drawable.demo)</span><br><span class="line">  .bitmapTransform(<span class="keyword">new</span> BlurTransformation(context, <span class="number">25</span>))</span><br><span class="line">  .into((ImageView) findViewById(R.id.image));</span><br></pre></td></tr></table></figure></p>
<p>如果同时需要对一个图片进行圆角转换和高斯模糊的话，<strong>bitmapTransform</strong>的参数，是一个<strong>可变数组</strong>,我们的代码可以这样写<br>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitmapTransform(<span class="keyword">new</span> BlurTransformation(context, <span class="number">25</span>), <span class="keyword">new</span> CropCircleTransformation(context))</span><br></pre></td></tr></table></figure></p>
<h3 id="后记">后记</h3>
<p><a href="https://github.com/wasabeef/glide-transformations" target="_blank" rel="external">glide-transformations</a>只是一个工具库，里面的工具类都是基于Glide的Transform接口，在Transform的基础上，我们也可以有一些自己的工具类，来实现一些特定的需求，Glide这个库，我并没有去深入的理解它的机制和流程（暂时没那么多时间去跟源码），有时间的小伙伴可以花一些时间，去把源码里，比较好的设计以及它的瓶颈在哪归纳整理出来，也是对自己的一种提高。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-android-push调研" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/22/android-push调研/" class="article-date">
  	<time datetime="2016-04-22T12:37:25.000Z" itemprop="datePublished">2016-04-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/22/android-push调研/">android push调研</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="项目现状">项目现状：</h3>
<p>当前推送退到后台的，很多机型存在不稳定的问题,android6.0以后，推出了[Doze模式] [1]，后台推送的权限进一步收紧。国内存在众多的自定义rom，会对后台的推送进程进行强杀。（MIUI，魅族等友商）</p>
<blockquote>
<p>在Doze Mode下，网络访问被屏蔽，维持唤醒（Wake Lock）被忽略，定时任务（Alarm）被推迟（以指数递增的后延），但不会杀进程。也就是说后台进程就啥都别想干了，乖乖躺着吧，push通道不可避免的会断掉。这次Google动真格的一点是，对所有应用，无视『目标版本（Target SDK Version）』全部生效，除了用户在设置中主动赦免的app以及Google自家的Play services和Play Store。（Google很贱的不让你剥夺这俩的赦免）</p>
</blockquote>
<h3 id="优化方向">优化方向</h3>
<p>暂时没有发现可靠的第三方库能对android的后台push有很好的保护，根据官方文档，有以下几种方案可以在一定程度上对push的送达率有优化作用<br>
- android5.0以后，建议使用[JobSchedlue] [2]进行后台任务的优化，通过更好的任务触发机制，降低应用耗电,降低被回收的概率<br>
- 针对android6.0的[Doze模式] [1],应用可以声明 REQUEST_IGNORE_BATTERY_OPTIMIZATIONS 权限，并主动要求用户将其加入至白名单中，从而不受Doze Mode和App Standby的影响。<br>
- 对现有的android应用做优化，减少后台时候的内存占用，尽可能的降低被android进程回收的优先级 - 通过native层搭建管道，监听进程状态，实现保活（非官方，短时间的调研过，效果不理想）[MarsDaemon] [3]参考项目</p>
<h3 id="预计工时">预计工时</h3>
<p>[JobSchedule] [2]和[Doze模式] [1]的方案是针对android系统正规方案，预计会花费<strong>1周左右</strong>的工作时间，android应用优化的方案是针对整个团队的，包括应用后台以后，webview的资源释放，图片资源的释放等一系列的优化方案，这个时间上不好预估。但是应该需要持续去做。native层进程监听保活的话，更多是时间比较空闲的时候，去跟进调研，预计时间<strong>一周</strong>，优先级可以放低。</p>
<h3 id="结论">结论</h3>
<p>在GCM没有办法进入国内的现阶段，应用尽量做到内存使用和电量损耗最小化，使进程被杀的概率尽量降低。针对小米的机器只能依赖于MiPush，能提供一个相对稳定的推送环境<br>
[1]: http://blog.csdn.net/aa20616012/article/details/49781875<br>
[2]: http://blog.csdn.net/bboyfeiyu/article/details/44809395<br>
[3]: https://github.com/lzhAndroid/MarsDaemon</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-android-emoji调研" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/04/22/android-emoji调研/" class="article-date">
  	<time datetime="2016-04-22T10:31:00.000Z" itemprop="datePublished">2016-04-22</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/22/android-emoji调研/">android emoji调研</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="调研背景">调研背景</h3>
<p>项目中的emoji逻辑过于繁琐，且维护成本相对较高，针对emoji的几套标准还做 了不同的处理，最近出的一些emoji表情没有支持。</p>
<h3 id="调研情况">调研情况</h3>
<p>当前主流的几套适配emoji的方案<br>
1. android4.4以上项目原生支持emoji<br>
2. 自己造轮子（在自有的库的基础上做优化）<br>
3. 使用第三方库</p>
<h3 id="原生支持">原生支持</h3>
<p>优点：</p>
<p>不需要额外导入表情库，减少安装包的体积。</p>
<p>缺点： 1. 风格不统一，缺乏广泛的辨别度 2. 支持的系统版本偏高，不是全平台支持</p>
<h3 id="自己造轮子">自己造轮子</h3>
<p>优点：</p>
<p>对以往的知识进行梳理,归纳和终结</p>
<p>缺点：</p>
<p>整套emoji的代码是基于五年前的经验搭建的，学习和借鉴的地方可能不多。而且代码相对 较为零散，整理的难度偏大</p>
<h3 id="使用第三方库建议方案">使用第三方库(<strong>建议方案</strong>）</h3>
<blockquote>
<p><a href="https://github.com/rockerhieu/emojicon" title="emojicon" target="_blank" rel="external">emojicon</a> is A library to show emoji in TextView, EditText (like WhatsApp) for Android</p>
</blockquote>
<p>优点： 1. 有开源社区的支持，最近一次更新是在4个月前 2. 源码相对条理性更强，维护难度小于项目中的代码 3. 受众范围更大，遇到问题有更多的issue解决方案</p>
<p>缺点： 1. 已知的源码在输入大量emoji表情的时候未做优化，会有卡顿 2. 可能需要对原有的代码进行一定工作量的改动 3. 改动可能会导致项目前期稳定性下降，但长远看，会提升项目的易维护性</p>
<h3 id="工期预计3天">工期预计：3天</h3>
<h3 id="总结">总结：</h3>
<p>最近出的emoji表情适配，方案二和方案三均没有办法很好的跟进支持，但是梳理清楚了代码逻辑以后，能提供一个方案很方便的接入新表情的支持。方案一的缺陷在于系统的限制性比较大。工作量的比较的话，方案二时间大于方案三大于方案一</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Mr.Monkey
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: true
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>